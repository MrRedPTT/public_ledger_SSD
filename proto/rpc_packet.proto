syntax = "proto3";

import "google/protobuf/empty.proto";
package rpcpacket;

service PacketSending {
  rpc Ping(PingPacket) returns (PongPacket);
  rpc Store(StoreRequest) returns (StoreResponse);  // Kademlia
  rpc FindNode(FindNodeRequest) returns (FindNodeResponse); // Kademlia
  rpc FindValue(FindValueRequest) returns (FindValueResponse); // Kademlia
  rpc SendTransaction(TransactionBroadcast) returns (google.protobuf.Empty); // BlockChain
  rpc SendBlock(BlockBroadcast) returns (google.protobuf.Empty); // BlockChain
  rpc GetBlock(GetBlockRequest) returns (GetBlockResponse); // BlockChain => Ask for a block already in the blockchain
}

message Address {
  bytes id = 1;
  string ip = 2;
  uint32 port = 3;
}

message PingPacket {
    // Maybe add the Identifier entry
    Address src = 1;
    Address dst = 2;
    bytes randID = 3;
}

message PongPacket {
  Address src = 1;
  Address dst = 2;
  bytes randID = 3;
}

message FindNodeRequest {
  bytes id = 1;
  Address src = 2;
  Address dst = 3;
}

message Node {
  bytes id = 1;        // Fixed-size array of 256 bytes
  string ip = 2;
  uint32 port = 3;
}

message kNearestNodes {
  repeated Node nodes = 1;
}

enum FindNodeResponseType {
  UNKNOWN_TYPE_FIND_NODE = 0; // Some weird value was passed for the enum
  KNear = 1; // The node was not found, return the up to k nearest nodes from the target id
  TargetNode = 2; // The node was found, returning it
}

message FindNodeResponse {
  FindNodeResponseType ResponseType = 1; // This is here so we can now which type of response we are getting
  Node node = 2;
  kNearestNodes list = 3;
}

message FindValueRequest {
  bytes value_id = 1; // Since every record is stored inside of a hashmap, we can pass a [u8; ID_LEN] (Identifier) as argument
  Address src = 2; // Node that originated the request
  Address dst = 3; // Node to which the request was originally sent
}

enum FindValueType {
  UNKNOWN_TYPE_FIND_VALUE = 0;
  ReRoute = 1;
  TargetValue = 2;
}

message FindValueResponse {
  FindValueType ResponseType = 1;
  kNearestNodes list = 2;
  string value = 3; // Might change later depending on what we choose to store

}

message StoreRequest {
  bytes key = 1;
  string value = 2;
  Address src = 3; // Node that originated the request
  Address dst = 4; // Node to which the request was originally sent
}

enum StoreType {
  UNKNOWN_TYPE_STORE = 0; // Error may have occurred
  LocalStore = 1; // The recipient node stored the value
  RemoteStore = 2; // The recipient has received notice that someone else along the line store the value
}

message StoreResponse {
  StoreType ResponseType = 1;
}

message Transaction {
  string from = 1;
  string to = 2;
  double amount_in = 3;
  double amount_out = 4;
  double miner_fee = 5;
}

message Block {
  string hash = 1;
  uint64 index = 2;
  uint64 timestamp = 3;
  string prev_hash = 4;
  uint64 nonce = 5;
  uint64 difficulty = 6;
  string miner_id = 7;
  string merkle_tree_root = 8;
  uint64 confirmations = 9;
  repeated Transaction transactions = 10;
}

message TransactionBroadcast {
  Address src = 1;
  Address dst = 2;
  Transaction transaction = 3;
  uint32 ttl = 4; // Limit the amount of hops the request will make to avoid overloading the network (let's make 15)
}

message BlockBroadcast {
  Address src = 1;
  Address dst = 2;
  Block block = 3;
  uint32 ttl = 4;
}


enum GetBlockType {
    UNKNOWN_TYPE_GET_BLOCK = 0;
    REROUTE = 1;
    TARGET_BLOCK = 2;
}

message GetBlockRequest {
  Address src = 1;
  Address dst = 2;
  string id = 3;
}

message GetBlockResponse {
  GetBlockType response_type = 1;
  kNearestNodes list = 2;
  Block block = 3;
}